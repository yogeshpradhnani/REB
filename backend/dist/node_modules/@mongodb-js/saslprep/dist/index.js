"use strict";
var getCodePoint = function getCodePoint(character) {
    return character.codePointAt(0);
};
var first = function first(x) {
    return x[0];
};
var last = function last(x) {
    return x[x.length - 1];
};
function toCodePoints(input) {
    var codepoints = [];
    var size = input.length;
    for (var i = 0; i < size; i += 1) {
        var before = input.charCodeAt(i);
        if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {
            var next = input.charCodeAt(i + 1);
            if (next >= 0xdc00 && next <= 0xdfff) {
                codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);
                i += 1;
                continue;
            }
        }
        codepoints.push(before);
    }
    return codepoints;
}
function saslprep(_ref, input) {
    var unassigned_code_points = _ref.unassigned_code_points;
    var commonly_mapped_to_nothing = _ref.commonly_mapped_to_nothing;
    var non_ASCII_space_characters = _ref.non_ASCII_space_characters;
    var prohibited_characters = _ref.prohibited_characters;
    var bidirectional_r_al = _ref.bidirectional_r_al;
    var bidirectional_l = _ref.bidirectional_l;
    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var mapping2space = non_ASCII_space_characters;
    var mapping2nothing = commonly_mapped_to_nothing;
    if (typeof input !== 'string') {
        throw new TypeError('Expected string.');
    }
    if (input.length === 0) {
        return '';
    }
    var mapped_input = toCodePoints(input).map(function (character) {
        return mapping2space.get(character) ? 0x20 : character;
    }).filter(function (character) {
        return !mapping2nothing.get(character);
    });
    var normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize('NFKC');
    var normalized_map = toCodePoints(normalized_input);
    var hasProhibited = normalized_map.some(function (character) {
        return prohibited_characters.get(character);
    });
    if (hasProhibited) {
        throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');
    }
    if (opts.allowUnassigned !== true) {
        var hasUnassigned = normalized_map.some(function (character) {
            return unassigned_code_points.get(character);
        });
        if (hasUnassigned) {
            throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');
        }
    }
    var hasBidiRAL = normalized_map.some(function (character) {
        return bidirectional_r_al.get(character);
    });
    var hasBidiL = normalized_map.some(function (character) {
        return bidirectional_l.get(character);
    });
    if (hasBidiRAL && hasBidiL) {
        throw new Error('String must not contain RandALCat and LCat at the same time,' + ' see https://tools.ietf.org/html/rfc3454#section-6');
    }
    var isFirstBidiRAL = bidirectional_r_al.get(getCodePoint(first(normalized_input)));
    var isLastBidiRAL = bidirectional_r_al.get(getCodePoint(last(normalized_input)));
    if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {
        throw new Error('Bidirectional RandALCat character must be the first and the last' + ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');
    }
    return normalized_input;
}
saslprep.saslprep = saslprep;
saslprep['default'] = saslprep;
module.exports = saslprep;
//# sourceMappingURL=index.js.map